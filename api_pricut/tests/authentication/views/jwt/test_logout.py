from apps.authentication.jwt import JWTErrorMessages, AccessToken
from apps.users.domain.constants import NATURAL_PERSON_ROLE, COMPANY_ROLE
from apps.exceptions import (
    NotAuthenticatedAPIError,
    JWTAPIError,
)
from tests.factories import JWTFactory, UserFactory
from rest_framework.fields import Field
from rest_framework import status
from django.test import Client
from django.urls import reverse
import pytest


# Error messages
DEFAULT_ERROR_MESSAGES = Field().error_messages
INVALID_OR_EXPIRED = JWTErrorMessages.INVALID_OR_EXPIRED.value
BLACKLISTED = JWTErrorMessages.BLACKLISTED.value


@pytest.mark.django_db
class TestLogoutAPIView:
    """
    This class encapsulates all the tests of the view responsible for handling a
    user's logout requests.

    A successful logout will consist of invalidating the last JSON Web Tokens
    generated by the user, adding them to a blacklist if they have not yet expired
    to prevent their further use.

    #### Clarifications:
    - The execution of this logic does not depend on the user's permissions; that is,
    the user's permissions are not validated.
    """

    path_name = "jwt_logout"
    user_factory = UserFactory
    jwt_factory = JWTFactory

    def test_if_access_token_not_provided(self, client: Client) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the access token is not provided.
        """

        # Simulating the request
        response = client.post(
            path=reverse(viewname=self.path_name),
            data={},
            content_type="application/json",
        )

        # Asserting that response data is correct
        status_code_expected = NotAuthenticatedAPIError.status_code
        code_expected = NotAuthenticatedAPIError.default_code
        message_expected = NotAuthenticatedAPIError.default_detail

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == message_expected

    @pytest.mark.parametrize(
        argnames="user_role",
        argvalues=[NATURAL_PERSON_ROLE, COMPANY_ROLE],
        ids=[f"{NATURAL_PERSON_ROLE}_user", f"{COMPANY_ROLE}_user"],
    )
    def test_if_request_data_invalid(self, user_role: str, client: Client) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the request data is valid.
        """

        # Creating the JWTs to be used in the test
        user_factory_obj = self.user_factory.create_user(
            user_role=user_role,
            save=True,
        )
        jwt_factory_obj = self.jwt_factory.create_token(
            token_type=AccessToken.token_type,
            user=user_factory_obj.user,
            save=True,
        )

        # Simulating the request
        response = client.post(
            path=reverse(viewname=self.path_name),
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {jwt_factory_obj.token}",
        )

        # Asserting that response data is correct
        assert response.status_code == status.HTTP_200_OK

    def test_if_access_token_invalid(self, client: Client) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the JWTs are invalid or expired.
        """

        jwt_factory_obj = self.jwt_factory.create_token(
            token_type=AccessToken.token_type,
            invalid=True,
        )

        # Simulating the request
        response = client.post(
            path=reverse(viewname=self.path_name),
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {jwt_factory_obj.token}",
        )

        # Asserting that response data is correct
        status_code_expected = JWTAPIError.status_code
        code_expected = JWTAPIError.default_code
        error_message_expected = INVALID_OR_EXPIRED.format(
            token_type=AccessToken.token_type
        )

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == error_message_expected

    @pytest.mark.parametrize(
        argnames="user_role",
        argvalues=[NATURAL_PERSON_ROLE, COMPANY_ROLE],
        ids=[f"{NATURAL_PERSON_ROLE}_user", f"{COMPANY_ROLE}_user"],
    )
    def test_if_access_token_expired(self, user_role: str, client: Client) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the JWTs are invalid or expired.
        """

        # Creating the JWTs to be used in the test
        user_factory_obj = self.user_factory.create_user(
            user_role=user_role,
            save=True,
        )
        jwt_factory_obj = self.jwt_factory.create_token(
            token_type=AccessToken.token_type,
            user=user_factory_obj.user,
            save=True,
            exp=True,
        )

        # Simulating the request
        response = client.post(
            path=reverse(viewname=self.path_name),
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {jwt_factory_obj.token}",
        )

        # Asserting that response data is correct
        status_code_expected = JWTAPIError.status_code
        code_expected = JWTAPIError.default_code
        error_message_expected = INVALID_OR_EXPIRED.format(token_type="access")

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == error_message_expected

    @pytest.mark.parametrize(
        argnames="user_role",
        argvalues=[NATURAL_PERSON_ROLE, COMPANY_ROLE],
        ids=[f"{NATURAL_PERSON_ROLE}_user", f"{COMPANY_ROLE}_user"],
    )
    def test_if_token_blacklisted(self, user_role: str, client: Client) -> None:
        """
        This test is responsible for validating the expected behavior of the view
        when the JWTs are blacklisted.
        """

        # Creating the JWTs to be used in the test
        user_factory_obj = self.user_factory.create_user(
            user_role=user_role,
            save=True,
        )
        jwt_factory_obj = self.jwt_factory.create_token(
            token_type=AccessToken.token_type,
            user=user_factory_obj.user,
            add_blacklist=True,
            save=True,
        )

        # Simulating the request
        response = client.post(
            path=reverse(viewname=self.path_name),
            content_type="application/json",
            HTTP_AUTHORIZATION=f"Bearer {jwt_factory_obj.token}",
        )

        # Asserting that response data is correct
        status_code_expected = JWTAPIError.status_code
        code_expected = JWTAPIError.default_code
        error_message_expected = BLACKLISTED.format(token_type="access")

        assert response.status_code == status_code_expected
        assert response.data["code"] == code_expected
        assert response.data["detail"] == error_message_expected
