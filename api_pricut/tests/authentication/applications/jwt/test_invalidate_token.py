from apps.authentication.applications import UseCaseInvalidateToken
from apps.authentication.domain.entities import JWTBlacklist
from apps.authentication.jwt import AccessToken
from apps.users.domain.constants import NATURAL_PERSON_ROLE, COMPANY_ROLE
from apps.exceptions import DatabaseConnectionAPIError
from tests.factories import JWTFactory, UserFactory
from unittest.mock import Mock
import pytest


@pytest.mark.django_db
class TestUseCaseInvalidateToken:
    """
    This class encapsulates all the tests of the JSON Web Token use case responsible
    for logging out a user.

    A successful logout will consist of invalidating the last JSON Web Tokens
    generated by the user, adding them to a blacklist if they have not yet expired,
    to prevent their further use.

    #### Clarifications:
    - The execution of this logic does not depend on the user's permissions; that is,
    the user's permissions are not validated.
    """

    application_class = UseCaseInvalidateToken
    user_factory = UserFactory
    jwt_factory = JWTFactory

    @pytest.mark.parametrize(
        argnames="user_role",
        argvalues=[NATURAL_PERSON_ROLE, COMPANY_ROLE],
        ids=[f"{NATURAL_PERSON_ROLE}_user", f"{COMPANY_ROLE}_user"],
    )
    def test_logout_user(self, user_role: str) -> None:
        """
        This test checks if the user is logged out correctly, adding the access
        token to the blacklist.
        """

        # Creating the JWTs to be used in the test
        user_factory_obj = self.user_factory.create_user(
            user_role=user_role,
            save=True,
        )
        jwt_factory_obj = self.jwt_factory.create_token(
            token_type=AccessToken.token_type,
            user=user_factory_obj.user,
            save=True,
        )
        access_token = AccessToken(payload=jwt_factory_obj.payload)

        # Asserting the tokens are not in the blacklist
        assert JWTBlacklist.objects.count() == 0

        # Instantiating the application and calling the method
        self.application_class.invalidate_token(access_token=access_token)

        # Assert that the refresh token was added to the blacklist
        assert JWTBlacklist.objects.filter(
            token__jti=access_token.payload["jti"]
        ).exists()

    def test_if_conection_db_failed(self) -> None:
        """
        Test that validates the expected behavior of the use case when the connection
        to the database fails.
        """

        # Mocking the methods
        access_token = Mock()
        blacklist: Mock = access_token.blacklist
        blacklist.side_effect = DatabaseConnectionAPIError

        # Instantiating the application
        with pytest.raises(DatabaseConnectionAPIError):
            self.application_class.invalidate_token(access_token=access_token)

        # Assert that the refresh token was not added to the blacklist
        assert JWTBlacklist.objects.count() == 0
